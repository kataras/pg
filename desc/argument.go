package desc

import (
	"fmt"
	"reflect"
)

// Argument represents a single argument for a database query
// It contains a column definition and a value.
type Argument struct {
	Column *Column // the column definition for the argument
	Value  any     // the value for the argument
}

// Arguments is a slice of Argument.
type Arguments []Argument

// Values returns a slice of values from the arguments.
func (args Arguments) Values() []any {
	values := make([]any, len(args)) // create a slice to hold the values
	for i := range args {
		values[i] = args[i].Value // assign each value from the argument to the slice
	}

	return values // return the slice of values
}

// ShiftEnd moves the argument with the given column name to the end of the slice.
func (args *Arguments) ShiftEnd(arg Argument) {
	for i, a := range *args {
		if a.Column.Name == arg.Column.Name { // already exists, move to the end and return.
			*args = shiftToEndEnd(*args, i)
			return
		}
	}

	*args = append(*args, arg) // append the argument to the end of the slice.
}

func shiftToEndEnd[T any](s []T, x int) []T {
	if x < 0 {
		return s
	}

	if x >= len(s)-1 {
		return s
	}

	tmp := s[x]
	s = append(s[:x], s[x+1:]...)
	s = append(s, tmp)
	return s
}

// extractArguments takes a reflect value of a struct and a table definition
// and returns a slice of arguments for each column in the table that is not auto-generated or has a default value.
func extractArguments(td *Table, structValue reflect.Value, filter func(columnName string) bool) (Arguments, error) {
	args := make(Arguments, 0, len(td.Columns)) // create a slice to hold the arguments

	for _, c := range td.Columns { // loop over each column in the table definition
		if c.AutoGenerated || c.Presenter {
			continue // skip this column if it is auto-generated
		}

		field := structValue.FieldByIndex(c.FieldIndex) // get the struct field by using the column field index
		if !field.CanInterface() {
			continue // skip this field if it cannot be converted to an interface
		}

		fieldValue := field.Interface() // get the field value as an interface

		if filter != nil {
			if !filter(c.Name) {
				continue
			}
		} else { // if no custom filter passed, then check by its zero value if no default value on database.
			if c.Default != "" {
				if isZero(field) {
					// skip this field if it has a default value and the field value is zero,
					// the createTable function has configured the database's default value option
					continue
				}
			}
		}

		if c.Default != "" && c.Type == UUID && c.PrimaryKey && !c.Nullable {
			if isZero(fieldValue) {
				continue // skip this field if it is a UUID primary key and required and the field value is zero
			}
		}

		if c.Password && td.PasswordHandler.canEncrypt() {
			passwordFieldValue, ok := fieldValue.(string)
			if !ok {
				return nil, fmt.Errorf("password field: %s is not string", c.Name)
			}

			if passwordFieldValue == "" {
				return nil, fmt.Errorf("password field: %s is empty", c.Name)
			}

			encryptedPassword, err := td.PasswordHandler.Encrypt(td.Name, passwordFieldValue)
			if err != nil {
				return nil, fmt.Errorf("password handler: set: %w", err)
			}

			fieldValue = encryptedPassword // replace the value with the new password text
		}

		args = append(args, Argument{
			Column: c,          // assign the column definition to the argument
			Value:  fieldValue, // assign the field value to the argument
		})
	}

	return args, nil // return the arguments and nil error
}

// filterArguments takes a slice of arguments and a filter function and returns a slice of arguments.
func filterArguments(args Arguments, filter func(arg Argument) bool) Arguments {
	var filtered Arguments
	for _, arg := range args {
		if filter(arg) {
			filtered = append(filtered, arg)
		}
	}
	return filtered
}

// FilterArgumentsForInsert takes a slice of arguments and returns a slice of arguments for insert.
func filterArgumentsForFullUpdate(args Arguments) Arguments {
	return filterArguments(args, func(arg Argument) bool {
		return !arg.Column.IsGenerated() && !arg.Column.Presenter // && !arg.Column.Unscannable
	})
}

// extractPrimaryKeyValues takes a table definition and a slice of reflect values of structs
// and returns the primary key column name and a slice of primary key values.
func extractPrimaryKeyValues(td *Table, values []any) (string, []any, error) {
	primaryKey, ok := td.PrimaryKey()
	if !ok {
		return "", nil, fmt.Errorf("no primary key found in table definition: %s", td.Name)
	}

	ids := make([]any, 0, len(values))
	for _, value := range values {
		idValue, err := ExtractPrimaryKeyValue(primaryKey, IndirectValue(value))
		if err != nil {
			return "", nil, err
		}

		ids = append(ids, idValue)
	}

	return primaryKey.Name, ids, nil
}

// ExtractPrimaryKeyValue takes a column definition and a reflect value of a struct
func ExtractPrimaryKeyValue(primaryKey *Column, structValue reflect.Value) (any, error) {
	idField := structValue.FieldByIndex(primaryKey.FieldIndex)
	if idField.IsZero() {
		return nil, fmt.Errorf("primary key field value is zero")
	}

	if !idField.CanInterface() {
		return nil, fmt.Errorf("primary key field value cannot be extracted")
	}

	idValue := idField.Interface()
	if idValue == nil {
		return nil, fmt.Errorf("primary key value is nil")
	}

	return idValue, nil
}
